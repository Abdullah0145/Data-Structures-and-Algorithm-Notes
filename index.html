<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data-Structures-And-Algorithms</title>
</head>
<body>
    <h2 style="color: black;">::Importance Data Structure and Algorithms Interviews Questions and Answers::</h2>
    <br>

    <p><b style="color: blue;">Ques1:</b> <b style="color: blue;">What is Data Structures?</b></p>
    <p><b style="color: green;">Ans:</b> <b>Data Structures:</b> once we have data in variables, we need some mechanism for manipulating that data to solve problems. Data structure is a particular way of storing and organizing data in a computer so that it can be used efficiently. A data structure is a special format for organizing and storing data. General data structure types include arrays, files, linked lists, stacks, queues, trees, graphs and so on..</p>
    <p><b>#</b> To store the data in a structured manner / (propered way). It is also called as Data Structures.</p>
    <p><b>Example of Data Structures:</b></p>
    <img src="./assets/./ExampleofDS1.jpeg" width="1200" height="600">
    <img src="./assets/ExampleofDS2.jpeg" width="1200" height="600">
    <br>

    <p><b style="color: blue;">Ques2:</b> <b style="color: blue;">How many types of the Data Structures classified into ways?</b></p>
    <p><b style="color: green;">Ans:</b> <b>Depending on the organization of the elements, Data structures are classified into two types:</b></p>
    <ol type="i">
        <li><b>Linear Data Structures</b></li>
        <li><b>Non-Linear Data Structures</b></li>
    </ol>
    <ol type="i">
        <li><b>Linear Data Structures:</b> Elements are accessed in a sequential order but it is not compulsory to store all elements sequentially. Examples: Linked Lists, Stacks and Queues.</li>
        <li><b>Non-Linear Data Structures:</b> Elements of this data structure are stored/accessed in a Non-linear order. Examples: Trees and graphs.</li>
    </ol>
    <br>

    <p><b style="color: blue;">Ques3:</b> <b style="color: blue;">How many different kinds of Data Structures we have in the list?</b></p>
    <p><b style="color: green;">Ans:</b> <b>There are so many kinds of Data Structures having:</b></p>
    <ol type="i">
        <li>Arrays</li>
        <li>Linked list</li>
        <li>Stacks</li>
        <li>Queues</li>
        <li>Trees</li>
        <li>Graphs</li>
        <li>Tries</li>
        <li>Hashing</li>
        <li>Heaps</li>
        <li>Greedy Algorithms</li>
        <li>and many more...</li>
    </ol>
    <br>

    <p><b style="color: blue;">Ques4:</b> <b style="color: blue;">What is an Algorithm?</b></p>
    <p><b style="color: green;">Ans:</b> An algorithm is the step-by-step unambiguous (unambigous means confusion / deterministic) instructions to solve a given problem.</p>
    <p><b>#</b> There are two main criteria for judging the merits of algorithms: correctness (does the algorithm give solution to the problem in a finite number of steps) and efficiency (how much resources in terms of memory and time does it take to execute).</p>
    <p><b>#</b> Algorithm is simpliy a sequence of finite steps that we need to execute to generate one final outcome that to in finite amount of time.</p>
    <p><b>Example of Algorithm:</b></p>
    <img src="./assets/./AlgorithmExample1.png" width="1080" height="450">
    <br>

    <p><b style="color: blue;">Ques5:</b> <b style="color: blue;">What are the properties of Algorithms?</b></p>
    <p><b style="color: green;">Ans:</b> <b>There are various properties of algorithms:</b></p>
    <ol type="i">
        <li>It should terminate after finite amount of time</li>
        <p><b>For simple example:</b></p>
        <p><b>While (True);</b></p>
        <p><b>print ('I am Abdullah')</b></p>
        <p>This is not a valid algorithm. because this particular code will execute infinite number of times. because every condition will be true and that is something which is point to be noted.</p>
        <li>It should produce atleast one output or more than one output.</li>
        <li>I am independent of any programming language, like: C, C++, Python, Java, JavaScript, etc..</li>
        <li>It should produce unambiguous (unambigous means confusion / Deterministic) 
        <p></p><b>For simple example:</b> if i take two numbers : 2 * 3 = 6  
        (this is right output) or 2 * 3 = 10 (this is wrong output). These is somethings which i would say is unambigous output, Which i should consider output 6 & 10, here my code is confused, i am also confused.(what i want is?) Every point of time whenever user inserting an input it should always gets the same output, That's the properties of code to the unambigous, that's the properties of deterministic </li> 
    </ol>
    <br>

    <p><b style="color: blue;">Ques6:</b> <b style="color: blue;">What are the different types of algorithms?</b></p>
    <p><b style="color: green;">Ans:</b> <b>There are two types of Algorithms, we have:</b></p>
    <ol>
        <li>Time Complexity</li>
        <li>Space Complexity</li>
    </ol>
    <br>

    <p><b style="color: blue">Ques7:</b> <b style="color: blue;">Why is complexity Analysis required?</b></p>
    <p><b style="color: green;">Ans:</b> Sometimes, there are more than one way to solve a problem, So, we need to learn how to compare the performance of different algorithms and choose the best one to solve a particular problem. While analayzing an algorithm, we mostly consider time complexity and space complexity. To know how efficent an algorithm or a program is, we neeed to do complexity analysis.</p>
    <br>

    <p><b style="color: blue;">Ques8:</b> <b style="color: blue;">Given two algorithms for a task, how do we find out which one is better?</b></p>
    <p><b style="color: green;">Ans:</b> One way of doing this is - implement both the algorithms and run the two programs on your computer for differnet inputs and see which one takes less time.</p>
    <p>There are many problems with this approach for analysis of algorithms.</p>
    <ol>
        <li>It might be posssible that for some inputs, the first algorithm performs better than the second. And for some inputs the second perfoem better.</li>
        <li>It might be also possible that for some inputs, the first algorithm perform better on one machine and the second works better on other machine for some other inputs.</li>
    </ol>
    <br>

    <p><b style="color: blue;">Ques9:</b> <b style="color: blue;">Why is the need for time complexity?</b></p>
    <p><b style="color: green;">Ans:</b> When analyzing any algorithm, we need to evaluate the effectiveness of that algorithm, accordingly, we need to prefer the most optimized algorithm so as to save the time taken by it to excute. An Example for the same could be linear search and binary search. Let's suppose we need to search a given value in a sorted array of size 8. this would take 8 iterations for linear search whereas it would just take log(8) - 3 iterations for binary search and linear search will be discussed in further lectures.</p>
    <br>

    <p><b style="color: blue;">Ques10:</b> <b style="color: blue;">What is Time Complexity (Analysis)?</b></p>
    <p><b style="color: green;">Ans:</b> <b>Introduction of Time Complexity:</b> Time complexity of an algorithm represents the amount of Time required by the algorithm to run to completion. Time requirements can be defined as a numerical function T(n), where T(n) can be measured as the number of steps, provided each step consumes constant time.</p>
    <p><b>#</b> Applying the asymptotic analysis to measure the time requirement of an algorithm as a function of input sizes is known as time complexity. We assume each instruction takes a constant amount of time for time complexity analysis.</p>
    <p><b>#</b> Total time complexity of a program is equal to the summation of all the running time of disconnected fragements.</p>
    <p><b>#</b> Algorithm analysis is an important part of computational complexity theory, which provides theoretical estimation for the required resources of an algorithm to solve a specific computational problem. Analysis of algorithms is the determination of the amount of time and space resources required to execute it.</p>
    <p><b>Example of Time Complexity:</b> addition of two n-bit integers takes n steps. Consequently, the total computational time is T(n) = c * n, where c is the time taken for the addition of two bits. Here, we observe that T(n) grows linearly as the input size increases</p>
    <p><b>#</b> An important question while programming is: How efficient is an algorithm or piece of code?</p>
        <p><b>#</b> Efficiency covers lots of resources, including:</p>
        <ol type="i">
            <li>CPU (time) usage</li>
            <li>memory usage</li>
            <li>disk usage</li>
            <li>network usage</li>
        </ol>
        <p><b>#</b> All are important but we are mostly concerned about CPU time. Be careful to differentiate between:</p>
            <ol type="i">
                <li><b>Performance:</b> how much time/memory/disk/etc. is actually used when a program is run. This depends on the machine, compiler, etc. as well as the code we write.</li>
                <li><b>Complexity:</b> how do the resource requirements of a program or algorithm scale, i.e. what happens as the size of the problem being solved by the code gets larger. Complexity affects performance but not vice-versa. The time required by a function/method is proportional to the number of "basic operations" that it performs.</li>
            </ol>
    <br>

    <p><b style="color: blue;">Ques11:</b> <b style="color: blue">How many different types of Time Complexity (Analysis)?</b></p>
    <p><b style="color: green;">Ans:</b> To analyze a given algorithm, we need to know, with which inputs the algorithm takes less time (i.e. the algorithm performs well) and with which inputs the algorithm takes a long time.</p>
    <p><b>#</b> Three types of Time Complexity (Analysis) are generally performed:</p>
    <ol type="i">
        <li><b>worst case Analysis (Big-O notation - O(n)) :</b> The worst-case consists of the input for which the algorithm takes the longest time to complete its execution. Big-O notation (O(n)) to represent the worst case analysis.</li>
        <li><b>Best case Analysis (Omega notation - Ω(1)) : </b> The best case consists of the input for which the algorithm takes the least time to complete its execution. Omega notation (Ω(1)) to represent the Best case analysis. </li>
        <li><b>Average case Analysis (Theta Notation - Θ(1)) : </b> The average case gives an idea about the average running time of the given algorithm. Theta notation (Θ(1)) to represent the average case analysis.</li>
    </ol>
    <br>
</body>
</html>